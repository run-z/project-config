import { type Config } from '@jest/types';
import deepmerge from 'deepmerge';
import path from 'node:path';
import process from 'node:process';
import { type ProjectConfig } from '../project-config.js';
import { ProjectTypescriptConfig } from '../typescript/project-typescript-config.js';

function ProjectJestConfig$create(this: void, project: ProjectConfig): ProjectJestConfig {
  const { jest } = project.tools;

  if (!jest) {
    return new ProjectJestConfig(project);
  }
  if (jest instanceof ProjectJestConfig) {
    return jest;
  }

  return new ProjectJestConfig(project).extendOptions(jest);
}

/**
 * Configuration of project tests utilizing Jest.
 */
export class ProjectJestConfig {

  /**
   * Gains Jest configuration of the project.
   *
   * Respects {@link ProjectToolsInit#jest defaults}.
   *
   * @param project - Configured project.
   *
   * @returns Jest configuration instance.
   */
  static of(project: ProjectConfig): ProjectJestConfig {
    return project.get(ProjectJestConfig$create);
  }

  /**
   * Loads Jest configuration from ESM module.
   *
   * If configuration file found, its options {@link ProjectJestConfig#replaceOptions replace} the default ones.
   * Default configuration returned otherwise.
   *
   * @param project - Configured project.
   * @param url - Jest configuration URL relative to project root. Defaults to `./jest.config.js`.
   *
   * @returns Loaded configuration.
   */
  static async load(project: ProjectConfig, url = './jest.config.js'): Promise<ProjectJestConfig> {
    const config = ProjectJestConfig.of(project);
    const options: Config.InitialOptions | null = await project.loadConfig(url, null);

    return options ? config.replaceOptions(options) : config;
  }

  readonly #project: ProjectConfig;
  #jest?: Promise<typeof import('jest')>;
  #autogenerated = true;
  #runner?: 'swc' | 'ts-jest';
  #customOptions: () => Config.InitialOptions | Promise<Config.InitialOptions>;
  #options?: Promise<Config.InitialOptions>;

  /**
   * Constructs project tests configuration.
   *
   * @param project - Configured project.
   */
  constructor(project: ProjectConfig) {
    this.#project = project;
    this.#customOptions = () => ({});
  }

  protected clone(): ProjectJestConfig {
    const clone = new ProjectJestConfig(this.project);

    clone.#runner = this.#runner;
    clone.#customOptions = this.#customOptions;

    return clone;
  }

  /**
   * Configured project.
   */
  get project(): ProjectConfig {
    return this.#project;
  }

  /**
   * Jest API instance.
   */
  get jest(): Promise<typeof import('jest')> {
    return (this.#jest ??= import('jest').then(jest => jest.default || jest));
  }

  /**
   * Whether options generated automatically prior to applying custom ones.
   *
   * `true` by default.
   */
  get autogenerated(): boolean {
    return this.#autogenerated;
  }

  /**
   * Test runner.
   *
   * Test may be run either with `swc`, or with `ts-jest`.
   *
   * @defaultValue `swc`, unless overridden by `RUNZ_TEST_RUNNER` environment variable.
   */
  get runner(): 'swc' | 'ts-jest' {
    return (this.#runner ??= ProjectJestConfig$defaultRunner());
  }

  /**
   * Assigns {@link runner test runner} to use.
   *
   * @param runner - Test runner to use.
   *
   * @returns Updated instance.
   */
  useRunner(runner: 'swc' | 'ts-jest'): ProjectJestConfig {
    const clone = this.clone();

    clone.#runner = runner;

    return clone;
  }

  /**
   * Promise resolved to customized Jest options.
   */
  get options(): Promise<Config.InitialOptions> {
    return (this.#options ||= this.#toOptions());
  }

  /**
   * Replaces Jest options with custom ones.
   *
   * Clears custom options, and prevents {@link autogenerated automatic generation}.
   *
   * @param options - Jest options to apply.
   *
   * @returns Updated instance.
   */
  replaceOptions(options: Config.InitialOptions): ProjectJestConfig {
    const clone = this.clone();

    clone.#autogenerated = false;
    clone.#customOptions = () => options;

    return clone;
  }

  /**
   * Replaces custom Rollup options with autogenerated ones.
   *
   * Clears custom options, and forces {@link autogenerated automatic generation}.
   *
   * @param options - Jest options extending autogenerated ones.
   *
   * @returns Updated instance.
   */
  autogenerateOptions(options: Config.InitialOptions): ProjectJestConfig {
    const clone = this.clone();

    clone.#autogenerated = true;
    clone.#customOptions = () => options;

    return clone;
  }

  /**
   * Extends Jest options.
   *
   * @param extension - Jest options extending previous ones.
   *
   * @returns Updated instance instance.
   */
  extendOptions(extension: Config.InitialOptions): ProjectJestConfig {
    const clone = this.clone();
    const prevOptions = this.#customOptions;

    clone.#customOptions = async () => deepmerge(await prevOptions(), extension);

    return clone;
  }

  async #toOptions(): Promise<Config.InitialOptions> {
    const customOptions = await this.#customOptions();

    if (!this.autogenerated) {
      return customOptions;
    }

    const swc = this.runner === 'swc';
    const output = await this.project.output;
    const { targetDir, cacheDir } = output;
    const config: Config.InitialOptions &
      Required<Pick<Config.InitialOptions, 'reporters' | 'transform'>> = {
      ...customOptions,
      cacheDirectory: path.join(cacheDir, 'jest'),
      extensionsToTreatAsEsm: customOptions.extensionsToTreatAsEsm ?? ['.ts'],
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1',
        ...customOptions.moduleNameMapper,
      },
      reporters: customOptions.reporters
        ? [...customOptions.reporters]
        : [
            'default',
            [
              'jest-junit',
              {
                suiteName: 'All Tests',
                outputDirectory: path.join(targetDir, 'test-results'),
                classNameTemplate: '{classname}: {title}',
                titleTemplate: '{classname}: {title}',
                ancestorSeparator: ' â€º ',
                usePathForSuiteName: 'false',
              },
            ],
          ],
      testEnvironment: customOptions.testEnvironment ?? 'node',
      transform: { ...customOptions.transform },
    };

    const tsConfig = ProjectTypescriptConfig.of(this.project);

    if (config.preset == null) {
      if (swc) {
        const { experimentalDecorators, emitDecoratorMetadata } = await tsConfig.options;

        config.transform['^.+\\.(t|j)sx?$'] = [
          '@swc/jest',
          {
            jsc: {
              parser: {
                syntax: 'typescript',
                decorators: experimentalDecorators,
                dynamicImport: true,
              },
              keepClassNames: true,
              preserveAllComments: true,
              target: 'es2020',
              transform: {
                legacyDecorator: experimentalDecorators,
                decoratorMetadata: emitDecoratorMetadata,
              },
            },
          },
        ];
      } else {
        config.preset = 'ts-jest/presets/default-esm';
        config.transform['^.+\\.tsx?$'] = [
          'ts-jest',
          {
            tsconfig: {
              ...(await tsConfig.options),
              esModuleInterop: true,
              noUnusedLocals: false,
              noUnusedParameters: false,
            },
            useESM: true,
          },
        ];
      }
    }
    if (process.env.CI === 'true' && process.env.GITHUB_ACTION) {
      config.reporters.push('github-actions');
    }

    const { collectCoverage = true } = customOptions;

    if (collectCoverage) {
      config.collectCoverage = true;

      const srcDir = path
        .relative(this.#project.rootDir, this.#project.sourceDir)
        .replaceAll(path.sep, '/');

      config.collectCoverageFrom = customOptions.collectCoverageFrom ?? [
        `${srcDir}/**/*.ts`,
        `!${srcDir}/**/*.spec.ts`,
        `!${srcDir}/spec/**`,
        '!**/node_modules/**',
      ];
      config.coverageDirectory =
        customOptions.coverageDirectory ?? path.join(targetDir, 'coverage');
      config.coverageThreshold = customOptions.coverageThreshold ?? {
        global: {
          statements: 100,
          branches: 100,
          functions: 100,
          lines: 100,
        },
      };
    }

    return config;
  }

  /**
   * Configures and run project tests with Jest.
   *
   * @param args - Array of Jest command line arguments. Defaults to arguments from `process.argv`.
   *
   * @returns Promise resolved when tests executed.
   */
  async run(args?: string[]): Promise<void> {
    const jest = await this.jest;

    await jest.run(args);
  }

}

function ProjectJestConfig$defaultRunner(): 'swc' | 'ts-jest' {
  switch (process.env.RUNZ_TEST_RUNNER) {
    case 'ts-jest':
      return 'ts-jest';
    case 'swc':
    default:
      return 'swc';
  }
}
