import { Stats } from 'node:fs';
import fs from 'node:fs/promises';
import path from 'node:path';
import { ProjectConfig } from '../project-config.js';
import { ProjectDevTool } from '../project-dev-tool.js';
import { ProjectOutput } from '../project-output.js';

/**
 * Abstract project entry configuration.
 *
 * @typeParam TEntry - Entry type.
 */
export abstract class ProjectEntry extends ProjectDevTool {

  #name?: Promise<string | null>;
  #sourceFile?: Promise<string | null>;
  #typesFile?: Promise<string | null>;

  protected override clone(): this {
    const clone = super.clone();

    clone.#name = this.#name;
    clone.#sourceFile = this.#sourceFile;
    clone.#typesFile = this.#typesFile;

    return clone;
  }

  /**
   * Whether this is the main entry.
   */
  get isMain(): boolean {
    return false;
  }

  /**
   * Whether this entry is generated by build tool.
   */
  get isGenerated(): Promise<boolean> {
    return this.#isGenerated();
  }

  async #isGenerated(): Promise<boolean> {
    const files = await Promise.all([this.distFiles, this.name, this.sourceFile, this.typesFile]);

    return files.every(file => !!file);
  }

  /**
   * Short entry name.
   *
   * By default, equals to {@link distFiles distribution file} path relative to {@link ProjectOutput#distDir
   * distribution directory} without an extension.
   *
   * May be `null` for {@link isGenerated non-generated entries}.
   */
  get name(): Promise<string | null> {
    return (this.#name ??= this.detectName());
  }

  /**
   * Assigns entry name.
   *
   * @param name - New entry name.
   *
   * @returns Updated instance.
   */
  withName(name: string): this {
    const clone = this.clone();

    clone.#name = Promise.resolve(name);

    return clone;
  }

  protected async detectName(): Promise<string | null> {
    const distFile = await this.#distFile();

    if (!distFile) {
      return null;
    }

    const fileExt = path.extname(distFile);

    const { distDir } = await this.project.output;
    const fileName = path.relative(distDir, path.resolve(distDir, distFile));

    return fileExt ? fileName.slice(0, -fileExt.length) : fileExt;
  }

  /**
   * Path to source file to transpile during the build relative to {@link ProjectConfig#sourceDir sources directory},
   * or `null` if this entry is not transpiled.
   *
   * By default, searches for `main.(m|c)?ts`, `mod.(m|c)?ts`, or `index.(m|c)?ts` file in sources sub-directory
   * corresponding to distribution file. Dots in distribution file name correspond to directory separators. The very
   * first dot-separated part is discarded.
   *
   * For example:
   *
   * - `./dist/main.js` converted to `./src/mod.ts`,
   * - `./dist/project.util.js` converted to `./src/util/mod.ts`,
   * - `./dist/util/mod.js` converted to `./src/util/mod.ts`.
   */
  get sourceFile(): Promise<string | null> {
    return (this.#sourceFile ??= this.detectSourceFile());
  }

  /**
   * Assigns source file to transpile during the build.
   *
   * @param file - New path to source file relative to {@link ProjectConfig#sourceDir sources directory}, or `null`
   * to not transpile this entry.
   *
   * @returns Updated instance.
   */
  withSourceFile(file: string | null): this {
    const clone = this.clone();

    clone.#sourceFile = Promise.resolve(file);

    return clone;
  }

  protected async detectSourceFile(): Promise<string | null> {
    let distFile = await this.#distFile();

    if (!distFile) {
      return null;
    }

    const { distDir } = await this.project.output;

    distFile = path.relative(distDir, path.resolve(distDir, distFile));

    const ext = path.extname(distFile);
    const name = ext ? distFile.slice(0, -ext.length) : ext;
    let parts = name.split(path.sep);
    const lastPart = parts[parts.length - 1];
    const lastParts = lastPart.split('.').slice(1);

    parts = [...parts.slice(0, -1), ...lastParts];

    return await this.#findSourceFile([...parts]);
  }

  async #findSourceFile(searchPath: readonly string[]): Promise<string | null> {
    for (const fileName of SOURCE_FILE_NAMES) {
      for (const extension of SOURCE_FILE_EXTENSIONS) {
        let filePath: string[];

        if (fileName) {
          filePath = [...searchPath, `${fileName}${extension}`];
        } else if (searchPath.length) {
          filePath = [...searchPath.slice(0, -1), searchPath[searchPath.length - 1] + extension];
        } else {
          continue;
        }

        let stat: Stats;

        try {
          stat = await fs.stat(path.join(this.project.sourceDir, ...filePath));
        } catch {
          continue;
        }

        if (stat.isFile()) {
          return path.join(...filePath);
        }
      }
    }

    return null;
  }

  /**
   * Path to distribution files relative to {@link ProjectOutput#distDir distribution directory}.
   *
   * This is typically a file listed in `package.json` exports section and generated from
   * {@link sourceFile source file}.
   *
   * May be `null` when distribution files missing.
   */
  abstract get distFiles(): Promise<ProjectEntry.DistFiles | null>;

  async #distFile(): Promise<string | undefined> {
    const distFiles = await this.distFiles;

    if (!distFiles) {
      return;
    }

    return distFiles.esm ?? distFiles.commonJS;
  }

  /**
   * Path to types definition file relative to {@link ProjectOutput#distDir distribution directory}.
   *
   * By default, equals to {@link name entry name} with `.d.ts` extension.
   *
   * May be `null` for non-generated file.
   */
  get typesFile(): Promise<string | null> {
    return (this.#typesFile ??= this.detectTypesFile());
  }

  /**
   * Assigns types definition file.
   *
   * @param file - New types definition file path relative to {@link ProjectOutput#distDir distribution directory}.
   *
   * @returns Updated instance.
   */
  withTypesFile(file: string): this {
    const clone = this.clone();

    clone.#typesFile = Promise.resolve(file);

    return clone;
  }

  protected async detectTypesFile(): Promise<string | null> {
    const name = await this.name;

    return `${name}.d.ts`;
  }

  async toGenerated(): Promise<(this & ProjectEntry.Generated) | undefined> {
    return (await this.isGenerated) ? (this as this & ProjectEntry.Generated) : undefined;
  }

}

export namespace ProjectEntry {
  /**
   * Distribution files.
   *
   * One of ESM or CommonJS distribution files should always present.
   */
  export type DistFiles = ESMDistFiles | CommonJSDistFiles;

  export interface ESMDistFiles {
    readonly esm: string;
    readonly commonJS?: string | undefined;
  }

  export interface CommonJSDistFiles {
    readonly esm?: string | undefined;
    readonly commonJS: string;
  }

  export interface Generated {
    readonly name: Promise<string>;
    readonly sourceFile: Promise<string>;
    readonly distFiles: Promise<DistFiles>;
    readonly typesFile: Promise<string>;
  }
}

const SOURCE_FILE_NAMES = [null, 'main', 'mod', 'index'];
const SOURCE_FILE_EXTENSIONS = ['.ts', '.mts', '.cts'];
